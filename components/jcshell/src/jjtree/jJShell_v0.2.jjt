

options {
   MULTI=true;
	NODE_EXTENDS="JJShellNode";
}

PARSER_BEGIN(JJShellParser)

public class JJShellParser {
}

PARSER_END(JJShellParser)


SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

TOKEN : /* Types */
{
 < BOOL: "boolean" >
| < BYTE: "byte" >
| < CHAR: "char" >
| < DOUBLE: "double" >
| < FLOAT: "float" >
| < INT: "int" >
| < LONG: "long" >
| < SHORT: "short" >
| < STRING: "string" >
| < VOID: "void" >
| < CONTINUE: "continue" >
| < BREAK: "break" >
| < CASE: "case" >
| < DO: "do" >
| < ELSE: "else" >
| < FALSE: "false" >
| < FOR: "for" >
| < IF: "if" >
| < IMPORT: "import" >
| < READ: "read" >
| < RETURN: "return" >
| < SWITCH: "switch" >
| < TRUE: "true" >
| < WHILE: "while" >
| < WRITE: "write" >
}

TOKEN : /* Literals */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/*
 * Program structuring syntax follows.
 */

void CompilationUnit() :
{}
{
   (
     LOOKAHEAD("include")
	 IncludeStatement()
   )*
   (
     LOOKAHEAD(ResultType() <IDENTIFIER> "(")
     MethodDeclaration()
   )*
   (
       LOOKAHEAD("int" "main" "(")
       MainMethodDeclaration()
     |
       LOOKAHEAD(Type() <IDENTIFIER>)
       VarDeclaration() ";"
   )*
   <EOF>
}

void VarDeclaration() :
{}
{
  Type() VariableDeclarator() ( "," VariableDeclarator() )*
}

void VariableDeclarator() :
{}
{
  VariableDeclaratorId()
  [ "=" VariableInitializer() ]
}

void VariableDeclaratorId() :
{ Token t; }
{
  t = <IDENTIFIER>
  (
  "[" "]" #ArrayDimNode
  )*
  { jjtThis.name = t.image; }
}

void MethodDeclaration() :
{}
{
  ResultType() MethodDeclarator()
  Block()
}

void MethodDeclarator() :
{ Token t; }
{
  t = <IDENTIFIER> FormalParameters()
  { jjtThis.method = t.image; }
}

void FormalParameters() :
{}
{
  "(" [ FormalParameter() ( "," FormalParameter() )* ] ")"
}

void FormalParameter() :
{}
{
  Type() VariableDeclaratorId()
}

void MainMethodDeclaration() :
{}
{
  "int" { jjtThis.type = INT; }
  MainMethodDeclarator()
  Block()
}

void MainMethodDeclarator() :
{}
{
  "main" MainParameter()
}

void MainParameter() :
{}
{
  "(" "string" MainDeclaratorId() ")"
}

void MainDeclaratorId() :
{}
{
  "args"
  (
  "[" "]" #ArrayDimNode
  )*
}

/*
 * Expression syntax follows.
 */

void Type() :
{}
{
  (
    "boolean" { jjtThis.type = BOOL; }
   |
    "char" { jjtThis.type = CHAR; }
   |
    "byte" { jjtThis.type = BYTE; }
   |
    "short" { jjtThis.type = SHORT; }
   |
    "int" { jjtThis.type = INT; }
   |
    "long" { jjtThis.type = LONG; }
   |
    "float" { jjtThis.type = FLOAT; }
   |
    "double" { jjtThis.type = DOUBLE; }
   |
    "string" { jjtThis.type = STRING; }
  )
}

void ResultType() :
{}
{
  "void" { jjtThis.type = VOID; }
|
  Type()
}

void Expression() #void:
{}
{
  LOOKAHEAD( PrimaryExpression() "=" )
  Assignment()
|
  LOOKAHEAD(<IDENTIFIER> "(")
  MethodCallStatement()
|
  ConditionalOrExpression()
|
  LOOKAHEAD( "++" )
  PreIncrementExpression()
|
  LOOKAHEAD( "--" )
  PreDecrementExpression()
|
  LOOKAHEAD( PrimaryExpression() "++" )
  PostIncrementExpression()
|
  LOOKAHEAD( PrimaryExpression() "--" )
  PostDecrementExpression()
}

void VariableInitializer() #void :
{}
{
  ArrayInitializer()
|
  Expression()
}

void ArrayInitializer() :
{}
{
  "{" [ VariableInitializer() ( LOOKAHEAD(2) "," VariableInitializer() )* ] [ "," ] "}"
}

void Assignment() #void :
{}
{
  LOOKAHEAD( PrimaryExpression() "=" )
  PrimaryExpression() "=" VariableInitializer() #Assignment(2)
|
  LOOKAHEAD( PrimaryExpression() "+=" )
  PrimaryExpression() "+=" VariableInitializer() #AddAssignment(2)
|
  LOOKAHEAD( PrimaryExpression() "-=" )
  PrimaryExpression() "-=" VariableInitializer() #SubstractAssignment(2)
|
  LOOKAHEAD( PrimaryExpression() "*=" )
  PrimaryExpression() "*=" VariableInitializer() #MultAssignment(2)
|
  LOOKAHEAD( PrimaryExpression() "/=" )
  PrimaryExpression() "/=" VariableInitializer() #DivAssignment(2)
|
  LOOKAHEAD( PrimaryExpression() "&=" )
  PrimaryExpression() "&=" VariableInitializer() #AndAssignment(2)
|
  LOOKAHEAD( PrimaryExpression() "%=" )
  PrimaryExpression() "%=" VariableInitializer() #ModAssignment(2)
|
  LOOKAHEAD( PrimaryExpression() "|=" )
  PrimaryExpression() "|=" VariableInitializer() #OrAssignment(2)
|
  LOOKAHEAD( PrimaryExpression() "^=" )
  PrimaryExpression() "^=" VariableInitializer() #XorAssignment(2)
}

void ConditionalOrExpression() #void :
{}
{
  ConditionalAndExpression()
  ( "||" ConditionalAndExpression() #OrNode(2) )*
}

void ConditionalAndExpression() #void :
{}
{
  InclusiveOrExpression()
  ( "&&" InclusiveOrExpression() #AndNode(2) )*
}

void InclusiveOrExpression() #void :
{}
{
  ExclusiveOrExpression()
  ( "|" ExclusiveOrExpression() #BitwiseOrNode(2) )*
}

void ExclusiveOrExpression() #void :
{}
{
  AndExpression()
  ( "^" AndExpression() #BitwiseXorNode(2) )*
}

void AndExpression() #void :
{}
{
  EqualityExpression()
  ( "&" EqualityExpression() #BitwiseAndNode(2) )*
}

void EqualityExpression() #void :
{}
{
  RelationalExpression()
  (
     "==" RelationalExpression() #EQNode(2)
   |
     "!=" RelationalExpression() #NENode(2)
  )*
}

void RelationalExpression() #void :
{}
{
  AdditiveExpression()
  (
    "<" AdditiveExpression() #LTNode(2)
   |
    ">" AdditiveExpression() #GTNode(2)
   |
    "<=" AdditiveExpression() #LENode(2)
   |
    ">=" AdditiveExpression() #GENode(2)
  )*
}

void AdditiveExpression() #void :
{}
{
  MultiplicativeExpression()
  (
    "+" MultiplicativeExpression() #AddNode(2)
   |
    "-" MultiplicativeExpression() #SubtractNode(2)
  )*
}

void MultiplicativeExpression() #void :
{}
{
  UnaryExpression()
  (
    "*" UnaryExpression() #MulNode(2)
   |
    "/" UnaryExpression() #DivNode(2)
   |
    "%" UnaryExpression() #ModNode(2)
  )*
}

void UnaryExpression() #void :
{}
{
  "~" UnaryExpression() #BitwiseComplNode(1)
|
  "!" UnaryExpression() #NotNode(1)
|
  LOOKAHEAD( "++" )
  PreIncrementExpression()
|
  LOOKAHEAD( "--" )
  PreDecrementExpression()
|
  LOOKAHEAD( PrimaryExpression() "++" )
  PostIncrementExpression()
|
  LOOKAHEAD( PrimaryExpression() "--" )
  PostDecrementExpression()
|
  PrimaryExpression()
}

void PreIncrementExpression() :
{}
{
  "++" PrimaryExpression()
}

void PreDecrementExpression() :
{}
{
  "--" PrimaryExpression()
}

void PostIncrementExpression() :
{}
{
  PrimaryExpression() "++"
}

void PostDecrementExpression() :
{}
{
  PrimaryExpression() "--"
}

void PrimaryExpression() #void :
{}
{
  LOOKAHEAD( <IDENTIFIER> "[" )
  ArrayId()
|
  Literal()
|
  "(" Expression() ")"
|
  Id() 
}

void Id() :
{
   Token t;
}
{
   t = <IDENTIFIER>  { jjtThis.name = t.image; }
}

void ArrayId() :
{
   Token t;
}
{
   t = <IDENTIFIER>  { jjtThis.name = t.image; }
   (
     "["
     (
     Id()
   |
  	 IntegerLiteral()
  	 )
     "]"
   )*
}

void Literal() #void :
{}
{
  BooleanLiteral()
|
  CharacterLiteral()
|
  IntegerLiteral()
|
  FloatLiteral()
|
  StringLiteral()
}

void BooleanLiteral() #void :
{}
{
  "true" #TrueNode
|
  "false" #FalseNode
}

void CharacterLiteral() #void :
{Token t;}
{
 (
  t=<CHARACTER_LITERAL>
    {
       jjtThis.val = t.image;
    }
 )#CharConstNode
}

void StringLiteral() #void :
{Token t;}
{
 (
  t=<STRING_LITERAL>
    {
       jjtThis.val = t.image;
    }
 )#StringConstNode
}

void IntegerLiteral() #void :
{Token t;}
{
 (
  t=<INTEGER_LITERAL>
    {
       jjtThis.val = t.image;
    }
 )#IntConstNode
}

void FloatLiteral() #void :
{Token t;}
{
 (
  t=<FLOATING_POINT_LITERAL>
    {
       jjtThis.val = t.image;
    }
 )#FloatConstNode
}

/*
 * Statement syntax follows.
 */

void Statement() #void :
{}
{
  ";"
|
  LOOKAHEAD(2)
  LabeledStatement()
|
  LOOKAHEAD(<IDENTIFIER> "(")
  MethodCallStatement() ";"
|
  Block()
|
  StatementExpression() ";"
|
  IfStatement()
|
  SwitchStatement()
|
  ForStatement()
|
  WhileStatement()
|
  DoWhileStatement()
|
  BreakStatement()
|
  ContinueStatement()
|
  ReturnStatement()
|
  IOStatement()
}

void LabeledStatement() #void :
{}
{
  <IDENTIFIER> ":" Statement()
}

void Block() :
{}
{
  "{"
   ( BlockStatement() )*
  "}"
}

void BlockStatement() #void :
{}
{
  LOOKAHEAD(Type() <IDENTIFIER>)
  VarDeclaration() ";"
|
  Statement()
}

void StatementExpression() :
/*
 * The last expansion of this production accepts more than the legal
 * SPL expansions for StatementExpression.
 */
{}
{
  LOOKAHEAD( "++" )
  PreIncrementExpression()
|
  LOOKAHEAD( "--" )
  PreDecrementExpression()
|
  LOOKAHEAD( PrimaryExpression() "++" )
  PostIncrementExpression()
|
  LOOKAHEAD( PrimaryExpression() "--" )
  PostDecrementExpression()
|
  Assignment()
}

void MethodCallStatement() :
{ Token t; }
{
  t = <IDENTIFIER> "(" [ Expression() ( "," Expression() )* ] ")"
  { jjtThis.method = t.image; }
}

void IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{}
{
  "if" "(" Expression() ")" Statement() [ LOOKAHEAD(1) "else" Statement() ]
}

void WhileStatement() :
{}
{
  "while" "(" Expression() ")" Statement()
}

void DoWhileStatement() :
{}
{
  "do" Statement() "while" "(" Expression() ")" ";"
}

void SwitchStatement() :
{}
{
  "switch" "(" Expression() ")" "{"
    ( SwitchLabel() ( BlockStatement() )* )*
  "}"
}

void SwitchLabel() #void :
{}
{
  "case" Expression() ":" #CaseNode(1)
|
  "default" ":" #DefaultNode
}

void ForStatement() :
{}
{
  "for" "(" [ ForInit() ] ";" [
  (
    Expression()
  )#ForExpression
  ] ";" [ ForUpdate() ] ")" Statement()
}

void ForInit() :
{}
{
  LOOKAHEAD( Type() <IDENTIFIER> )
  VarDeclaration()
|
  StatementExpressionList()
}

void StatementExpressionList() #void :
{}
{
  StatementExpression() ( "," StatementExpression() )*
}

void ForUpdate() :
{}
{
  StatementExpressionList()
}

void BreakStatement() :
{}
{
  "break" ";"
}

void ContinueStatement() :
{}
{
  "continue" ";"
}

void ReturnStatement() :
{}
{
  "return" [ Expression() ] ";"
}

void IncludeStatement() :
{ Token t; }
{
  "include" t = <STRING_LITERAL> ";"
   { jjtThis.path = t.image; }
}

void IOStatement() #void :
{}
{
   ReadStatement()
 |
   WriteStatement()
}

void ReadStatement() :
{ Token t; }
{
   "read" t = <IDENTIFIER>
   { jjtThis.name = t.image; }
}

void WriteStatement() :
{ /*Token t;*/ }
{
/*   "write" t = <IDENTIFIER>
   { jjtThis.name = t.image; } */
   
   "write" Expression()
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}
